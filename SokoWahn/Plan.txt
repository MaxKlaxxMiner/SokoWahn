
--- Room-Portals ---
- Vorbereitung
-- Room-Klasse erstellen
--- Rooms aus allen gültigen Feldern erstellen
---- Basis-Funktionalität
----- für Portale zugehörige Varianten ermitteln, und in den Portalen speichern
------ durch das Portal in den Raum laufen
------ Kiste durch das Portal in dem Raum schieben

- Optimizer
-- Rooms untereinander vergleichen (nur welche über Portale verbunden sind)
-- überflüssige Varianten entfernen
-- nicht mehr benötigte Zustände entfernen

- Merge: zwei Rooms zu einen verschmelzen
-- mögliche Varianten berechnen und in den Räumen speichern
--- alle Varianten ab der Startstellung vorwärts durchrechnen
---- 1. Spieler beginnt an der Startstellung innerhalb der Raumes
---- 2. Spieler hat den Raum über ein Portal betrten
--- alle Varianten von der Endstellung rückwärts durchrechnen
---- 1. Spieler verbleibt nach erreichen des Zieles im Raum
---- 2. Spieler verlässt nach erreichen des Zieles den Raum wieder
--- beide Ergebnislisten abgleichen und nicht erreichbare Varianten verwerfen
-- Merge weiter planen

- Search: Suche durchführen
-- Vorwärts-Scan
-- Rückwärts-Scan
-- gefundene Lösung verknüpfen
-- auf optimale Lösung prüfen
- DisplayConsole
-- Portal-Varianten auswählbar machen
--- Details der Varianten zeigen (z.B. Anzahl der Spielzüge um einen bestimmten Zustand zu erreichen)
--- Laufwege der Varianten darstellen


--- Projekte erstellen und einrichten ---

- SokoWahnHelper erstellen (Window-Forms Programm)
-- Projekt erstellen und zur Solution hinzufügen
-- Projekt auf AnyCpu umstellen
-- SokoWahnLib verweisen
- SokoWahnTest erstellen (Unit-Test)
-- Projekt erstellen und zur Solution hinzufügen
-- SokoWahnLib verweisen


--- Basis-Spiel erstellen ---

- einfaches Spielfeld erstellen (Textbasiert) mit Test-Map
-- allgemeines Interface und entsprechende Methoden für das Spielfeld erstellen
--- grundlegende Spielfunktionen hinzufügen
---- Spielerbewegung, jeweils: links, rechts, oben und unten
----- Bewegung ausführen
------ Schritte jeder Art merken
------- Rückwärts-Funktion hinzufügen
-------- Einzel-Schritt-Variante
-------- Letzter-Kistenwechsel-Variante
- reale Spielbarkeit hinzufügen
-- generische Erweiterungsmethode, ob das Spielende bereits erreicht wurde
-- wurde die End-Stellung bereits erreicht
-- zählen, wieviele Spielzüge bereits gemacht wurden (moves)
-- zählen, wieviele Kistenzüge bereits gemacht wurden (pushes)
- grafische Darstellung des Spielfeldes


--- Helper: einfache Suche nach direkt kürzeren Laufwegen ---


--- Helper: Klickbarkeit auf ein Feld, wohin sich der Spieler direkt bewegen soll ---


--- Helper: einfachen Blocker erstellen (verbotene Stellungen für Kisten markieren) ---


--- Helper: drag & drop für einfache Kisten hinzufügen ---


--- Helper: drag & drop für komplexe Kisten-Kombination hinzufügen ---


--- Helper: drag & drop für nachträglich korrigerbare Kisten hinzufügen ---


--- Speed: Felder-Logik aufbauen (64-Bit optimierte Bitmap, 2 Bits pro Spielfeld) ---


--- Speed: Laufwege-Map erstellen ---


--- Solver: kisten-basierete Brute Force Suche (vorwärts & rückwärts, um gezielte Teil- und/oder Komplettlösungen zu erreichen) ---


--- Scanner: Kistenwege-Map erstellen, ob und wie schnell (steps) eine Kiste ein bestimmtes Ziel erreichen kann (durch Rückwärts-Suche und mit Erweiterung auf Multi-Kisten) ---


--- Optimizer: laufwege-basierte Brute Force Suche (vorwärts & rückwärts, um optimale Lösungen für Teil- und/oder Komplettlösungen zu erreichen) ---
